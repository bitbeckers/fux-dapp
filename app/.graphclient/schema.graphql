schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Evaluation {
  id: ID!
  creator: User!
  workstream: Workstream!
  contributor: User!
  rating: BigInt!
}

input Evaluation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  creator: String
  creator_not: String
  creator_gt: String
  creator_lt: String
  creator_gte: String
  creator_lte: String
  creator_in: [String!]
  creator_not_in: [String!]
  creator_contains: String
  creator_contains_nocase: String
  creator_not_contains: String
  creator_not_contains_nocase: String
  creator_starts_with: String
  creator_starts_with_nocase: String
  creator_not_starts_with: String
  creator_not_starts_with_nocase: String
  creator_ends_with: String
  creator_ends_with_nocase: String
  creator_not_ends_with: String
  creator_not_ends_with_nocase: String
  creator_: User_filter
  workstream: String
  workstream_not: String
  workstream_gt: String
  workstream_lt: String
  workstream_gte: String
  workstream_lte: String
  workstream_in: [String!]
  workstream_not_in: [String!]
  workstream_contains: String
  workstream_contains_nocase: String
  workstream_not_contains: String
  workstream_not_contains_nocase: String
  workstream_starts_with: String
  workstream_starts_with_nocase: String
  workstream_not_starts_with: String
  workstream_not_starts_with_nocase: String
  workstream_ends_with: String
  workstream_ends_with_nocase: String
  workstream_not_ends_with: String
  workstream_not_ends_with_nocase: String
  workstream_: Workstream_filter
  contributor: String
  contributor_not: String
  contributor_gt: String
  contributor_lt: String
  contributor_gte: String
  contributor_lte: String
  contributor_in: [String!]
  contributor_not_in: [String!]
  contributor_contains: String
  contributor_contains_nocase: String
  contributor_not_contains: String
  contributor_not_contains_nocase: String
  contributor_starts_with: String
  contributor_starts_with_nocase: String
  contributor_not_starts_with: String
  contributor_not_starts_with_nocase: String
  contributor_ends_with: String
  contributor_ends_with_nocase: String
  contributor_not_ends_with: String
  contributor_not_ends_with_nocase: String
  contributor_: User_filter
  rating: BigInt
  rating_not: BigInt
  rating_gt: BigInt
  rating_lt: BigInt
  rating_gte: BigInt
  rating_lte: BigInt
  rating_in: [BigInt!]
  rating_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Evaluation_filter]
  or: [Evaluation_filter]
}

enum Evaluation_orderBy {
  id
  creator
  creator__id
  creator__fuxer
  workstream
  workstream__id
  workstream__name
  workstream__deadline
  workstream__uri
  workstream__status
  contributor
  contributor__id
  contributor__fuxer
  rating
}

"""
8 bytes signed integer

"""
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  workstream(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Workstream
  workstreams(
    skip: Int = 0
    first: Int = 100
    orderBy: Workstream_orderBy
    orderDirection: OrderDirection
    where: Workstream_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Workstream!]!
  rewardDistribution(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardDistribution
  rewardDistributions(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardDistribution_orderBy
    orderDirection: OrderDirection
    where: RewardDistribution_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardDistribution!]!
  evaluation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Evaluation
  evaluations(
    skip: Int = 0
    first: Int = 100
    orderBy: Evaluation_orderBy
    orderDirection: OrderDirection
    where: Evaluation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Evaluation!]!
  workstreamContributor(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkstreamContributor
  workstreamContributors(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkstreamContributor_orderBy
    orderDirection: OrderDirection
    where: WorkstreamContributor_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkstreamContributor!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  userBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserBalance
  userBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: UserBalance_orderBy
    orderDirection: OrderDirection
    where: UserBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserBalance!]!
  workstreamBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkstreamBalance
  workstreamBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkstreamBalance_orderBy
    orderDirection: OrderDirection
    where: WorkstreamBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkstreamBalance!]!
  workstreamContestation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkstreamContestation
  workstreamContestations(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkstreamContestation_orderBy
    orderDirection: OrderDirection
    where: WorkstreamContestation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkstreamContestation!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type RewardDistribution {
  id: ID!
  workstream: Workstream!
  contributors(skip: Int = 0, first: Int = 100, orderBy: User_orderBy, orderDirection: OrderDirection, where: User_filter): [User!]!
  shares: [BigInt!]!
}

input RewardDistribution_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  workstream: String
  workstream_not: String
  workstream_gt: String
  workstream_lt: String
  workstream_gte: String
  workstream_lte: String
  workstream_in: [String!]
  workstream_not_in: [String!]
  workstream_contains: String
  workstream_contains_nocase: String
  workstream_not_contains: String
  workstream_not_contains_nocase: String
  workstream_starts_with: String
  workstream_starts_with_nocase: String
  workstream_not_starts_with: String
  workstream_not_starts_with_nocase: String
  workstream_ends_with: String
  workstream_ends_with_nocase: String
  workstream_not_ends_with: String
  workstream_not_ends_with_nocase: String
  workstream_: Workstream_filter
  contributors: [String!]
  contributors_not: [String!]
  contributors_contains: [String!]
  contributors_contains_nocase: [String!]
  contributors_not_contains: [String!]
  contributors_not_contains_nocase: [String!]
  contributors_: User_filter
  shares: [BigInt!]
  shares_not: [BigInt!]
  shares_contains: [BigInt!]
  shares_contains_nocase: [BigInt!]
  shares_not_contains: [BigInt!]
  shares_not_contains_nocase: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RewardDistribution_filter]
  or: [RewardDistribution_filter]
}

enum RewardDistribution_orderBy {
  id
  workstream
  workstream__id
  workstream__name
  workstream__deadline
  workstream__uri
  workstream__status
  contributors
  shares
}

type Subscription {
  user(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): User
  users(
    skip: Int = 0
    first: Int = 100
    orderBy: User_orderBy
    orderDirection: OrderDirection
    where: User_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [User!]!
  workstream(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Workstream
  workstreams(
    skip: Int = 0
    first: Int = 100
    orderBy: Workstream_orderBy
    orderDirection: OrderDirection
    where: Workstream_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Workstream!]!
  rewardDistribution(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardDistribution
  rewardDistributions(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardDistribution_orderBy
    orderDirection: OrderDirection
    where: RewardDistribution_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardDistribution!]!
  evaluation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Evaluation
  evaluations(
    skip: Int = 0
    first: Int = 100
    orderBy: Evaluation_orderBy
    orderDirection: OrderDirection
    where: Evaluation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Evaluation!]!
  workstreamContributor(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkstreamContributor
  workstreamContributors(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkstreamContributor_orderBy
    orderDirection: OrderDirection
    where: WorkstreamContributor_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkstreamContributor!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  userBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): UserBalance
  userBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: UserBalance_orderBy
    orderDirection: OrderDirection
    where: UserBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [UserBalance!]!
  workstreamBalance(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkstreamBalance
  workstreamBalances(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkstreamBalance_orderBy
    orderDirection: OrderDirection
    where: WorkstreamBalance_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkstreamBalance!]!
  workstreamContestation(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkstreamContestation
  workstreamContestations(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkstreamContestation_orderBy
    orderDirection: OrderDirection
    where: WorkstreamContestation_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkstreamContestation!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: ID!
  tokenID: BigInt
  decimals: BigInt
  name: String
  symbol: String
  userBalances(skip: Int = 0, first: Int = 100, orderBy: UserBalance_orderBy, orderDirection: OrderDirection, where: UserBalance_filter): [UserBalance!]
  workstreamBalance(skip: Int = 0, first: Int = 100, orderBy: WorkstreamBalance_orderBy, orderDirection: OrderDirection, where: WorkstreamBalance_filter): [WorkstreamBalance!]
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  tokenID: BigInt
  tokenID_not: BigInt
  tokenID_gt: BigInt
  tokenID_lt: BigInt
  tokenID_gte: BigInt
  tokenID_lte: BigInt
  tokenID_in: [BigInt!]
  tokenID_not_in: [BigInt!]
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  userBalances_: UserBalance_filter
  workstreamBalance_: WorkstreamBalance_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  tokenID
  decimals
  name
  symbol
  userBalances
  workstreamBalance
}

type User {
  id: ID!
  fuxer: Boolean!
  balances(skip: Int = 0, first: Int = 100, orderBy: UserBalance_orderBy, orderDirection: OrderDirection, where: UserBalance_filter): [UserBalance!]
  workstreams(skip: Int = 0, first: Int = 100, orderBy: WorkstreamContributor_orderBy, orderDirection: OrderDirection, where: WorkstreamContributor_filter): [WorkstreamContributor!]
  evaluations(skip: Int = 0, first: Int = 100, orderBy: Evaluation_orderBy, orderDirection: OrderDirection, where: Evaluation_filter): [Evaluation!]
}

type UserBalance {
  id: ID!
  user: User!
  token: Token!
  amount: BigInt!
}

input UserBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [UserBalance_filter]
  or: [UserBalance_filter]
}

enum UserBalance_orderBy {
  id
  user
  user__id
  user__fuxer
  token
  token__id
  token__tokenID
  token__decimals
  token__name
  token__symbol
  amount
}

input User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  fuxer: Boolean
  fuxer_not: Boolean
  fuxer_in: [Boolean!]
  fuxer_not_in: [Boolean!]
  balances_: UserBalance_filter
  workstreams_: WorkstreamContributor_filter
  evaluations_: Evaluation_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [User_filter]
  or: [User_filter]
}

enum User_orderBy {
  id
  fuxer
  balances
  workstreams
  evaluations
}

type Workstream {
  id: ID!
  name: String
  coordinator: User
  deadline: BigInt
  contributors(skip: Int = 0, first: Int = 100, orderBy: WorkstreamContributor_orderBy, orderDirection: OrderDirection, where: WorkstreamContributor_filter): [WorkstreamContributor!]
  evaluations(skip: Int = 0, first: Int = 100, orderBy: Evaluation_orderBy, orderDirection: OrderDirection, where: Evaluation_filter): [Evaluation!]
  funding(skip: Int = 0, first: Int = 100, orderBy: WorkstreamBalance_orderBy, orderDirection: OrderDirection, where: WorkstreamBalance_filter): [WorkstreamBalance!]
  contestings(skip: Int = 0, first: Int = 100, orderBy: WorkstreamContestation_orderBy, orderDirection: OrderDirection, where: WorkstreamContestation_filter): [WorkstreamContestation!]
  rewardDistribution: RewardDistribution
  uri: String
  status: WorkstreamStatus
}

type WorkstreamBalance {
  id: ID!
  workstream: Workstream!
  token: Token!
  amount: BigInt!
}

input WorkstreamBalance_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  workstream: String
  workstream_not: String
  workstream_gt: String
  workstream_lt: String
  workstream_gte: String
  workstream_lte: String
  workstream_in: [String!]
  workstream_not_in: [String!]
  workstream_contains: String
  workstream_contains_nocase: String
  workstream_not_contains: String
  workstream_not_contains_nocase: String
  workstream_starts_with: String
  workstream_starts_with_nocase: String
  workstream_not_starts_with: String
  workstream_not_starts_with_nocase: String
  workstream_ends_with: String
  workstream_ends_with_nocase: String
  workstream_not_ends_with: String
  workstream_not_ends_with_nocase: String
  workstream_: Workstream_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [WorkstreamBalance_filter]
  or: [WorkstreamBalance_filter]
}

enum WorkstreamBalance_orderBy {
  id
  workstream
  workstream__id
  workstream__name
  workstream__deadline
  workstream__uri
  workstream__status
  token
  token__id
  token__tokenID
  token__decimals
  token__name
  token__symbol
  amount
}

type WorkstreamContestation {
  id: ID!
  user: User!
  workstream: Workstream!
  uri: String!
}

input WorkstreamContestation_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  user_: User_filter
  workstream: String
  workstream_not: String
  workstream_gt: String
  workstream_lt: String
  workstream_gte: String
  workstream_lte: String
  workstream_in: [String!]
  workstream_not_in: [String!]
  workstream_contains: String
  workstream_contains_nocase: String
  workstream_not_contains: String
  workstream_not_contains_nocase: String
  workstream_starts_with: String
  workstream_starts_with_nocase: String
  workstream_not_starts_with: String
  workstream_not_starts_with_nocase: String
  workstream_ends_with: String
  workstream_ends_with_nocase: String
  workstream_not_ends_with: String
  workstream_not_ends_with_nocase: String
  workstream_: Workstream_filter
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [WorkstreamContestation_filter]
  or: [WorkstreamContestation_filter]
}

enum WorkstreamContestation_orderBy {
  id
  user
  user__id
  user__fuxer
  workstream
  workstream__id
  workstream__name
  workstream__deadline
  workstream__uri
  workstream__status
  uri
}

type WorkstreamContributor {
  id: ID!
  workstream: Workstream!
  contributor: User!
  commitment: BigInt
  active: Boolean
}

input WorkstreamContributor_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  workstream: String
  workstream_not: String
  workstream_gt: String
  workstream_lt: String
  workstream_gte: String
  workstream_lte: String
  workstream_in: [String!]
  workstream_not_in: [String!]
  workstream_contains: String
  workstream_contains_nocase: String
  workstream_not_contains: String
  workstream_not_contains_nocase: String
  workstream_starts_with: String
  workstream_starts_with_nocase: String
  workstream_not_starts_with: String
  workstream_not_starts_with_nocase: String
  workstream_ends_with: String
  workstream_ends_with_nocase: String
  workstream_not_ends_with: String
  workstream_not_ends_with_nocase: String
  workstream_: Workstream_filter
  contributor: String
  contributor_not: String
  contributor_gt: String
  contributor_lt: String
  contributor_gte: String
  contributor_lte: String
  contributor_in: [String!]
  contributor_not_in: [String!]
  contributor_contains: String
  contributor_contains_nocase: String
  contributor_not_contains: String
  contributor_not_contains_nocase: String
  contributor_starts_with: String
  contributor_starts_with_nocase: String
  contributor_not_starts_with: String
  contributor_not_starts_with_nocase: String
  contributor_ends_with: String
  contributor_ends_with_nocase: String
  contributor_not_ends_with: String
  contributor_not_ends_with_nocase: String
  contributor_: User_filter
  commitment: BigInt
  commitment_not: BigInt
  commitment_gt: BigInt
  commitment_lt: BigInt
  commitment_gte: BigInt
  commitment_lte: BigInt
  commitment_in: [BigInt!]
  commitment_not_in: [BigInt!]
  active: Boolean
  active_not: Boolean
  active_in: [Boolean!]
  active_not_in: [Boolean!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [WorkstreamContributor_filter]
  or: [WorkstreamContributor_filter]
}

enum WorkstreamContributor_orderBy {
  id
  workstream
  workstream__id
  workstream__name
  workstream__deadline
  workstream__uri
  workstream__status
  contributor
  contributor__id
  contributor__fuxer
  commitment
  active
}

enum WorkstreamStatus {
  Started
  Evaluation
  Closed
}

input Workstream_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  coordinator: String
  coordinator_not: String
  coordinator_gt: String
  coordinator_lt: String
  coordinator_gte: String
  coordinator_lte: String
  coordinator_in: [String!]
  coordinator_not_in: [String!]
  coordinator_contains: String
  coordinator_contains_nocase: String
  coordinator_not_contains: String
  coordinator_not_contains_nocase: String
  coordinator_starts_with: String
  coordinator_starts_with_nocase: String
  coordinator_not_starts_with: String
  coordinator_not_starts_with_nocase: String
  coordinator_ends_with: String
  coordinator_ends_with_nocase: String
  coordinator_not_ends_with: String
  coordinator_not_ends_with_nocase: String
  coordinator_: User_filter
  deadline: BigInt
  deadline_not: BigInt
  deadline_gt: BigInt
  deadline_lt: BigInt
  deadline_gte: BigInt
  deadline_lte: BigInt
  deadline_in: [BigInt!]
  deadline_not_in: [BigInt!]
  contributors_: WorkstreamContributor_filter
  evaluations_: Evaluation_filter
  funding_: WorkstreamBalance_filter
  contestings_: WorkstreamContestation_filter
  rewardDistribution: String
  rewardDistribution_not: String
  rewardDistribution_gt: String
  rewardDistribution_lt: String
  rewardDistribution_gte: String
  rewardDistribution_lte: String
  rewardDistribution_in: [String!]
  rewardDistribution_not_in: [String!]
  rewardDistribution_contains: String
  rewardDistribution_contains_nocase: String
  rewardDistribution_not_contains: String
  rewardDistribution_not_contains_nocase: String
  rewardDistribution_starts_with: String
  rewardDistribution_starts_with_nocase: String
  rewardDistribution_not_starts_with: String
  rewardDistribution_not_starts_with_nocase: String
  rewardDistribution_ends_with: String
  rewardDistribution_ends_with_nocase: String
  rewardDistribution_not_ends_with: String
  rewardDistribution_not_ends_with_nocase: String
  rewardDistribution_: RewardDistribution_filter
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  status: WorkstreamStatus
  status_not: WorkstreamStatus
  status_in: [WorkstreamStatus!]
  status_not_in: [WorkstreamStatus!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Workstream_filter]
  or: [Workstream_filter]
}

enum Workstream_orderBy {
  id
  name
  coordinator
  coordinator__id
  coordinator__fuxer
  deadline
  contributors
  evaluations
  funding
  contestings
  rewardDistribution
  rewardDistribution__id
  uri
  status
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}